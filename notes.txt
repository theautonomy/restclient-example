package com.example.custom;

import java.util.*;
import java.util.function.Consumer;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * Custom implementation of RestClient to demonstrate how Builder pattern
 * and Consumer<HttpHeaders> work behind the scenes
 */
public class CustomRestClient {
    
    private final String baseUrl;
    private final HttpHeaders defaultHeaders;
    
    // Private constructor - can only be created through Builder
    private CustomRestClient(String baseUrl, HttpHeaders defaultHeaders) {
        this.baseUrl = baseUrl;
        this.defaultHeaders = new HttpHeaders(defaultHeaders); // Defensive copy
        System.out.println("✓ CustomRestClient created with baseUrl: " + baseUrl);
        System.out.println("✓ Default headers: " + defaultHeaders.getHeaders());
    }
    
    public String getBaseUrl() {
        return baseUrl;
    }
    
    public HttpHeaders getDefaultHeaders() {
        return new HttpHeaders(defaultHeaders); // Return copy to prevent external modification
    }
    
    // Simulate making a GET request
    public String get(String path) {
        System.out.println("\n=== Making GET request ===");
        System.out.println("URL: " + baseUrl + path);
        System.out.println("Headers that will be sent:");
        defaultHeaders.getHeaders().forEach((key, value) -> 
            System.out.println("  " + key + ": " + value));
        return "Simulated response from " + baseUrl + path;
    }
    
    // Static method to create builder - entry point
    public static Builder builder() {
        System.out.println("🔧 Creating new CustomRestClient.Builder");
        return new Builder();
    }
    
    /**
     * Custom HttpHeaders implementation to demonstrate how headers are managed
     */
    public static class HttpHeaders {
        private final Map<String, String> headers;
        
        public HttpHeaders() {
            this.headers = new LinkedHashMap<>(); // LinkedHashMap to preserve order
            System.out.println("📋 New HttpHeaders instance created");
        }
        
        // Copy constructor
        public HttpHeaders(HttpHeaders other) {
            this.headers = new LinkedHashMap<>(other.headers);
        }
        
        public void set(String name, String value) {
            System.out.println("📝 Setting header: " + name + " = " + value);
            headers.put(name, value);
        }
        
        public void setBasicAuth(String username, String password) {
            String credentials = username + ":" + password;
            String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
            String authValue = "Basic " + encoded;
            System.out.println("🔐 Setting Basic Auth for user: " + username);
            System.out.println("    Encoded credentials: " + authValue);
            set("Authorization", authValue);
        }
        
        public void setBearerAuth(String token) {
            System.out.println("🔑 Setting Bearer token: " + token.substring(0, Math.min(token.length(), 10)) + "...");
            set("Authorization", "Bearer " + token);
        }
        
        public String get(String name) {
            return headers.get(name);
        }
        
        public Map<String, String> getHeaders() {
            return new LinkedHashMap<>(headers); // Return copy
        }
        
        public int size() {
            return headers.size();
        }
        
        public void forEach(java.util.function.BiConsumer<String, String> action) {
            headers.forEach(action);
        }
        
        @Override
        public String toString() {
            return headers.toString();
        }
    }
    
    /**
     * Builder class that demonstrates the builder pattern mechanics
     */
    public static class Builder {
        private String baseUrl;
        private HttpHeaders defaultHeaders;
        
        public Builder() {
            this.defaultHeaders = new HttpHeaders();
            System.out.println("🏗️  Builder initialized with empty headers");
        }
        
        public Builder baseUrl(String baseUrl) {
            System.out.println("🌐 Builder.baseUrl() called with: " + baseUrl);
            this.baseUrl = baseUrl;
            return this; // Return this for method chaining
        }
        
        public Builder defaultHeader(String name, String value) {
            System.out.println("📌 Builder.defaultHeader() called: " + name + " = " + value);
            this.defaultHeaders.set(name, value);
            System.out.println("   Current headers in builder: " + defaultHeaders.getHeaders());
            return this; // Return this for method chaining
        }
        
        /**
         * This is the key method that demonstrates how Consumer<HttpHeaders> works!
         */
        public Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer) {
            System.out.println("\n🎯 Builder.defaultHeaders(Consumer) called!");
            System.out.println("   Headers before consumer: " + defaultHeaders.getHeaders());
            
            // This is the magic! We pass our HttpHeaders object to the consumer
            System.out.println("   🔄 Executing consumer function...");
            headersConsumer.accept(this.defaultHeaders);
            
            System.out.println("   Headers after consumer: " + defaultHeaders.getHeaders());
            System.out.println("✅ Consumer execution completed\n");
            
            return this; // Return this for method chaining
        }
        
        public CustomRestClient build() {
            System.out.println("\n🔨 Builder.build() called - Creating final CustomRestClient");
            System.out.println("   Final baseUrl: " + baseUrl);
            System.out.println("   Final headers: " + defaultHeaders.getHeaders());
            
            if (baseUrl == null) {
                throw new IllegalStateException("baseUrl must be set");
            }
            
            return new CustomRestClient(baseUrl, defaultHeaders);
        }
    }
}

/**
 * Demonstration class showing how everything works together
 */
class CustomRestClientDemo {
    
    public static void main(String[] args) {
        System.out.println("=".repeat(60));
        System.out.println("CUSTOM RESTCLIENT IMPLEMENTATION DEMO");
        System.out.println("=".repeat(60));
        
        // Demo 1: Basic builder usage
        System.out.println("\n>>> DEMO 1: Basic Builder Usage <<<");
        demoBasicBuilder();
        
        // Demo 2: Consumer mechanics
        System.out.println("\n>>> DEMO 2: Consumer Mechanics <<<");
        demoConsumerMechanics();
        
        // Demo 3: Complex consumer with conditional logic
        System.out.println("\n>>> DEMO 3: Complex Consumer Logic <<<");
        demoComplexConsumer();
        
        // Demo 4: Multiple consumers
        System.out.println("\n>>> DEMO 4: Multiple Consumer Calls <<<");
        demoMultipleConsumers();
    }
    
    private static void demoBasicBuilder() {
        CustomRestClient client = CustomRestClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeader("Content-Type", "application/json")
                .defaultHeader("User-Agent", "CustomClient/1.0")
                .build();
                
        client.get("/users");
    }
    
    private static void demoConsumerMechanics() {
        // This demonstrates exactly how the Consumer<HttpHeaders> works
        CustomRestClient client = CustomRestClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeader("Static-Header", "StaticValue")
                .defaultHeaders(headers -> {
                    System.out.println("      🎭 Inside consumer function!");
                    System.out.println("      📊 Headers object received: " + headers.getHeaders());
                    System.out.println("      🔢 Current header count: " + headers.size());
                    
                    // Now we can call methods on the headers object
                    headers.set("Dynamic-Header", "DynamicValue");
                    headers.setBasicAuth("myuser", "mypass");
                    
                    System.out.println("      📊 Headers after modifications: " + headers.getHeaders());
                    System.out.println("      🔢 Final header count: " + headers.size());
                })
                .build();
                
        client.get("/data");
    }
    
    private static void demoComplexConsumer() {
        String environment = "production";
        boolean enableAuth = true;
        String apiKey = "secret-api-key-12345";
        
        CustomRestClient client = CustomRestClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeaders(headers -> {
                    System.out.println("      🤖 Complex consumer executing...");
                    
                    // Conditional logic based on environment
                    if ("production".equals(environment)) {
                        headers.set("X-Environment", "PROD");
                        headers.set("X-Rate-Limit", "1000");
                        System.out.println("      🏭 Production headers added");
                    } else {
                        headers.set("X-Environment", "DEV");
                        headers.set("X-Rate-Limit", "100");
                        System.out.println("      🧪 Development headers added");
                    }
                    
                    // Conditional authentication
                    if (enableAuth) {
                        headers.setBearerAuth(apiKey);
                        System.out.println("      🔐 Authentication enabled");
                    }
                    
                    // Dynamic values
                    headers.set("X-Request-ID", UUID.randomUUID().toString());
                    headers.set("X-Timestamp", String.valueOf(System.currentTimeMillis()));
                    System.out.println("      ⏰ Dynamic headers added");
                })
                .build();
                
        client.get("/secure-data");
    }
    
    private static void demoMultipleConsumers() {
        // This shows that you can call defaultHeaders multiple times
        CustomRestClient client = CustomRestClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeaders(headers -> {
                    System.out.println("      🥇 First consumer");
                    headers.set("First-Header", "FirstValue");
                })
                .defaultHeaders(headers -> {
                    System.out.println("      🥈 Second consumer");
                    headers.set("Second-Header", "SecondValue");
                    System.out.println("      📋 Headers available from previous consumer: " + headers.get("First-Header"));
                })
                .defaultHeaders(headers -> {
                    System.out.println("      🥉 Third consumer");
                    headers.set("Third-Header", "ThirdValue");
                    System.out.println("      📊 All headers so far: " + headers.getHeaders());
                })
                .build();
                
        client.get("/multi-consumer-test");
    }
}

/**
 * Additional class to demonstrate how you might extend this pattern
 */
class AdvancedConsumerExamples {
    
    // Example of a reusable consumer
    public static Consumer<CustomRestClient.HttpHeaders> productionHeaders() {
        return headers -> {
            headers.set("X-Environment", "PRODUCTION");
            headers.set("X-Rate-Limit", "5000");
            headers.set("X-Monitoring", "enabled");
        };
    }
    
    // Example of a parameterized consumer factory
    public static Consumer<CustomRestClient.HttpHeaders> authHeaders(String token) {
        return headers -> {
            headers.setBearerAuth(token);
            headers.set("X-Auth-Method", "Bearer");
        };
    }
    
    // Example of a consumer that uses other consumers
    public static Consumer<CustomRestClient.HttpHeaders> combinedHeaders(String environment, String token) {
        return headers -> {
            // Apply base headers first
            if ("production".equals(environment)) {
                productionHeaders().accept(headers);
            }
            
            // Then apply auth
            if (token != null) {
                authHeaders(token).accept(headers);
            }
            
            // Add correlation ID
            headers.set("X-Correlation-ID", UUID.randomUUID().toString());
        };
    }
    
    public static void demonstrateReusableConsumers() {
        System.out.println("\n>>> REUSABLE CONSUMERS DEMO <<<");
        
        CustomRestClient client = CustomRestClient.builder()
                .baseUrl("https://api.example.com")
                .defaultHeaders(productionHeaders())
                .defaultHeaders(authHeaders("my-secret-token"))
                .defaultHeaders(combinedHeaders("production", "another-token"))
                .build();
                
        client.get("/advanced-example");
    }
}

/*
Ah, I understand now! You want to see a custom implementation of RestClient to understand how the builder pattern and Consumer work internally. Let me create a simplified version that demonstrates the mechanics.This custom implementation demonstrates exactly how the RestClient builder pattern and Consumer mechanism work behind the scenes:

## Key Mechanics Revealed:

### 1. **Builder Pattern Implementation**
```java
public static Builder builder() {
    return new Builder(); // Creates new builder instance
}
```
- The static factory method creates a fresh Builder instance
- Builder maintains internal state (`baseUrl`, `defaultHeaders`)
- Each method returns `this` for method chaining

### 2. **Consumer<HttpHeaders> Mechanics**
```java
public Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer) {
    headersConsumer.accept(this.defaultHeaders); // Key line!
    return this;
}
```
**This is the magic!** The builder:
1. Takes your lambda/consumer function as a parameter
2. Calls `headersConsumer.accept(this.defaultHeaders)` 
3. This passes the actual `HttpHeaders` object TO your function
4. Your function receives it and can call methods on it directly
5. Any changes you make are persisted in the builder's state

### 3. **HttpHeaders Object Lifecycle**
- Created once in Builder constructor
- Passed by reference to each consumer
- Modified directly by consumer functions
- Copied defensively when building final RestClient

### 4. **Behind the Scenes Flow**
When you write:
```java
.defaultHeaders(headers -> {
    headers.set("Custom-Header", "Value");
    headers.setBasicAuth("user", "pass");
})
```

What actually happens:
1. Builder receives your lambda function
2. Builder calls `yourLambda.accept(builderHeaders)`
3. Your lambda receives the actual headers object
4. You modify it directly
5. Changes are stored in the builder
6. Process repeats for each `defaultHeaders()` call

### 5. **Why Consumer Pattern is Powerful**
- **Direct Manipulation**: You get direct access to the headers object
- **Full API Access**: Can use convenience methods like `setBasicAuth()`
- **Conditional Logic**: Can make decisions based on runtime conditions
- **State Inspection**: Can examine existing headers before adding new ones
- **Reusability**: Can create reusable consumer functions

### 6. **Method Chaining Magic**
Each builder method returns `this`, enabling:
```java
builder.method1().method2().method3().build()
```

The demo output shows exactly when each step happens, making the internal mechanics visible. This is how Spring's actual RestClient works internally - your consumer functions receive the real headers object and can modify it directly!
*/